<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `lexpr` crate."><meta name="keywords" content="rust, rustlang, rust-lang, lexpr"><title>lexpr - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../lexpr/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Crate lexpr</p><div class="block version"><p>Version 0.2.6</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all lexpr's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><p class="location"></p><div id="sidebar-vars" data-name="lexpr" data-ty="mod" data-relpath="../"></div></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="">lexpr</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/lexpr/lib.rs.html#1-384" title="goto source code">[src]</a></span></h1><div class="docblock"><p>This crate provides facilities for parsing, printing and
manipulating S-expression data. S-expressions are the format used
to represent code and data in the Lisp language family.</p>
<pre><code class="language-scheme">((name . &quot;John Doe&quot;)
 (age . 43)
 (address
  (street &quot;10 Downing Street&quot;)
  (city &quot;London&quot;))
 (phones &quot;+44 1234567&quot; &quot;+44 2345678&quot;))
</code></pre>
<p><code>lexpr</code> also supports more complex types; including keywords and
configurable tokens for <code>true</code>, <code>false</code> and <code>nil</code>, by default
using Scheme syntax:</p>
<pre><code class="language-scheme">(define-class rectangle ()
 (width
   #:init-value #nil ;; Nil value
   #:settable #t     ;; true
   #:guard (&gt; width 10)
 )
 (height
   #:init-value 10
   #:writable #f ;; false
  ))
</code></pre>
<p>Note that keywords, and the corresponding <code>#:</code> notation, is not
part of standard Scheme, but is supported by <code>lexpr</code>'s default
parser settings.</p>
<p>There are three common ways that you might find yourself needing
to work with S-expression data in Rust:</p>
<ul>
<li>
<p><strong>As text data</strong>. An unprocessed string of S-expression data
that you receive from a Lisp program, read from a file, or
prepare to send to a Lisp program.</p>
</li>
<li>
<p><strong>As an dynamically typed representation</strong>. Maybe you want to check that
some S-expression data is valid before passing it on, but without knowing
the structure of what it contains. Or you want to handle arbirarily
structured data, like Lisp code.</p>
</li>
<li>
<p><strong>As a statically typed Rust data structure</strong>. When you expect all
or most of your data to conform to a particular structure and
want to get real work done without the dynamically typed nature
of S-expressions tripping you up.</p>
</li>
</ul>
<p>Only the first two items of this list are handled by <code>lexpr</code>; for conversion
from and to statically typed Rust data structures see the <a href="https://docs.rs/serde-lexpr"><code>serde-lexpr</code></a>
crate.</p>
<h1 id="operating-on-dynamically-typed-s-expression-data" class="section-header"><a href="#operating-on-dynamically-typed-s-expression-data">Operating on dynamically typed S-expression data</a></h1>
<p>Any valid S-expression can be manipulated using the <a href="../lexpr/enum.Value.html" title="Value"><code>Value</code></a> data
structure.</p>
<h2 id="constructing-s-expression-values" class="section-header"><a href="#constructing-s-expression-values">Constructing S-expression values</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
 <span class="kw">use</span> <span class="ident">lexpr</span>::{<span class="ident">Value</span>, <span class="ident">parse</span>::<span class="ident">Error</span>};

<span class="comment">// Some s-expressions a &amp;str.</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">r#&quot;((name . &quot;John Doe&quot;)
               (age . 43)
               (phones &quot;+44 1234567&quot; &quot;+44 2345678&quot;))&quot;#</span>;

<span class="comment">// Parse the string of data into lexpr::Value.</span>
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">lexpr</span>::<span class="ident">from_str</span>(<span class="ident">data</span>)<span class="question-mark">?</span>;

<span class="comment">// Access parts of the data by indexing with square brackets.</span>
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Please call {} at the number {}&quot;</span>, <span class="ident">v</span>[<span class="string">&quot;name&quot;</span>], <span class="ident">v</span>[<span class="string">&quot;phones&quot;</span>][<span class="number">1</span>]);

<span class="prelude-val">Ok</span>(())</pre></div>
<h1 id="what-are-s-expressions" class="section-header"><a href="#what-are-s-expressions">What are S-expressions?</a></h1>
<p>S-expressions, as mentioned above, are the notation used by various dialects
of Lisp to represent data (and code). As a data format, it is roughly
comparable to JSON (JavaScript Object Notation), but syntactically more
lightweight. Also, JSON is designed for consumption and generation by
machines, which is reflected by the fact that it does not specify a syntax
for comments. S-expressions on the other hand, are intended to be written
and read by humans as well as machines. In this respect, they are more like
YAML, but have a simpler and less syntactically rigid structure. For
example, indentation does not convey any information to the parser, but is
used only to allow for easier digestion by humans.</p>
<p>Different Lisp dialects have notational differences for some data types, and
some may lack specific data types completely. This section tries to give an
overview over the different types of values representable by the <a href="../lexpr/enum.Value.html" title="Value"><code>Value</code></a>
data type and how it relates to different Lisp dialects. All examples are
given in the syntax used in <a href="https://www.gnu.org/software/guile/">Guile</a>
Scheme implementation.</p>
<p>The parser and serializer implementation in <code>lexpr</code> can be
tailored to parse and generate S-expression data in various
&quot;dialects&quot; in use by different Lisp variants; the aim is to cover
large parts of R6RS and R7RS Scheme with some Guile and Racket
extensions, as well as Emacs Lisp.</p>
<p>In the following, the S-expression values that are modeled by
<code>lexpr</code> are introduced, In general, S-expression values can be
split into the two categories primitive types and compound types.</p>
<h2 id="primitive-types" class="section-header"><a href="#primitive-types">Primitive types</a></h2>
<p>Primitive, or non-compound types are those that can not
recursively contain arbitrary other values. Numbers,
strings and booleans fall into this category.</p>
<h3 id="symbols-and-keywords" class="section-header"><a href="#symbols-and-keywords">Symbols and keywords</a></h3>
<p>Lisp has a data type not commonly found in other languages, namely
&quot;symbols&quot;. A symbol is conceptually similar to identifiers in other
languages, but allow for a much richer set of characters than typically
allowed for identifiers in other languages. Also, identifiers in other
languages can usually not be used in data; Lisps expose them as a
primitive data type, a result of the
<a href="https://en.wikipedia.org/wiki/Homoiconicity">homoiconicity</a> of the Lisp
language family.</p>
<pre><code class="language-scheme">this-is-a-symbol ; A single symbol, dashes are allowed
another.symbol   ; Periods are allowed as well
foo$bar!&lt;_&gt;?     ; As are quite a few other characters
</code></pre>
<p>Another data type, present in some Lisp dialects, such as Emacs
Lisp, Common Lisp, and several Scheme implementations, are
keywords. These are also supported by <code>lexpr</code>. Keywords are very
similiar to symbols, but are typically prefixed by <code>:</code> or <code>#:</code> and
are used for different purposes in the language.</p>
<pre><code class="language-lisp">#:foo ; A keyword named &quot;foo&quot;, written in Guile/Racket notation
:bar  ; A keyword named &quot;bar&quot;, written in Emacs Lisp or Common Lisp notation
</code></pre>
<h3 id="booleans" class="section-header"><a href="#booleans">Booleans</a></h3>
<p>While Scheme has a primitive boolean data type, more traditional Lisps such
as Emacs Lisp and Common Lisp do not; they instead use the symbols <code>t</code> and
<code>nil</code> to represent boolean values. Using parser options, <code>lexpr</code> allows to
parse these symbols as booleans, which may be desirable in some
circumstances, as booleans are simpler to handle than symbols.</p>
<pre><code class="language-scheme">#t ; The literal representing true
#f ; The literal representing false
</code></pre>
<h3 id="the-empty-list-and-nil" class="section-header"><a href="#the-empty-list-and-nil">The empty list and &quot;nil&quot;</a></h3>
<p>In traditional Lisps, the end of list is represented as by a
special atom written as <code>nil</code>. In Scheme, the empty list is an
atom written as <code>()</code>, and there <code>nil</code> is just a regular
symbol. Both <code>nil</code> and the empty list are present and
distinguishable in <code>lexpr</code>.</p>
<h3 id="numbers" class="section-header"><a href="#numbers">Numbers</a></h3>
<p>Numbers are represented by the <a href="../lexpr/struct.Number.html" title="Number"><code>Number</code></a> abstract data type. It can handle
signed and unsigned integers, each up to 64 bit size, as well as floating
point numbers. The Scheme syntax for hexadecimal, octal, and binary literals
is supported.</p>
<pre><code class="language-scheme">1 -4 3.14  ; A postive, negative, and a floating point number
#xDEADBEEF ; An integer written using decimal notation
#o0677     ; Octal
#b10110    ; Binary
</code></pre>
<p>Scheme has an elaborate numerical type hierarchy (called &quot;numeric tower&quot;),
which supports fractionals, numbers of arbitrary size, and complex
numbers. These more advanced number types are not yet supported by <code>lexpr</code>.</p>
<h3 id="characters" class="section-header"><a href="#characters">Characters</a></h3>
<p>Characters are unicode codepoints, represented by Rust's <code>char</code> data type
embedded in the <a href="../lexpr/enum.Value.html#variant.Char" title="Value::Char"><code>Value::Char</code></a> variant.</p>
<h3 id="strings" class="section-header"><a href="#strings">Strings</a></h3>
<pre><code class="language-scheme">&quot;Hello World!&quot;
</code></pre>
<h2 id="lists" class="section-header"><a href="#lists">Lists</a></h2>
<p>Lists are a sequence of values, of either atoms or lists. In fact,
Lisp does not have a &quot;real&quot; list data type, but instead lists are
represented by chains of so-called &quot;cons cells&quot;, which are used to
form a singly-linked list, terminated by the empty list (or <code>nil</code>
in tradional Lisps). It is also possible for the terminator to not
be the empty list, but instead be af an arbitrary other data type.
In this case, the list is refered to as an &quot;improper&quot; or &quot;dotted&quot;
list. Here are some examples:</p>
<pre><code class="language-scheme">(&quot;Hello&quot; &quot;World&quot;)   ; A regular list
;; A list having with another, single-element, list as
;; its second item
(&quot;Hello&quot; (&quot;World&quot;))
(1 . 2) ; A cons cell, represented as an improper list by `lexpr`
(1 2 . 3) ; A dotted (improper) list
</code></pre>
<p>Lists are not only used to represent sequences of values, but also
associative arrays, also known as maps. A map is represented as a list
containing cons cells, where the first field of each cons cell, called
<code>car</code>, for obscure historical reasons, is the key, and the second field
(<code>cdr</code>) of the cons cell is the associated value.</p>
<pre><code class="language-scheme">;; An association list with the symbols `a` and `b` as keys
((a . 42) (b . 43))
</code></pre>
<h2 id="vectors" class="section-header"><a href="#vectors">Vectors</a></h2>
<p>In contrast to lists, which are represented as singly-linked chains of &quot;cons
cells&quot;, vectors allow O(1) indexing, and thus are quite similar to Rusts
<code>Vec</code> datatype.</p>
<pre><code class="language-scheme">#(1 2 &quot;three&quot;) ; A vector in Scheme notation
</code></pre>
<h2 id="byte-vectors" class="section-header"><a href="#byte-vectors">Byte vectors</a></h2>
<p>Byte vectors are similar to regular vectors, but are uniform: each element
only holds a single byte, i.e. an exact integer in the range of 0 to 255,
inclusive.</p>
<pre><code class="language-scheme">#u8(41 42 43) ; A byte vector
</code></pre>
</div><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<table><tr class="module-item"><td><a class="mod" href="cons/index.html" title="lexpr::cons mod">cons</a></td><td class="docblock-short"><p>List &quot;cons cell&quot; data type and accompanying iterator types.</p>
</td></tr><tr class="module-item"><td><a class="mod" href="datum/index.html" title="lexpr::datum mod">datum</a></td><td class="docblock-short"><p>S-expression values including source location.</p>
</td></tr><tr class="module-item"><td><a class="mod" href="number/index.html" title="lexpr::number mod">number</a></td><td class="docblock-short"><p>Dynamically typed number type.</p>
</td></tr><tr class="module-item"><td><a class="mod" href="parse/index.html" title="lexpr::parse mod">parse</a></td><td class="docblock-short"><p>S-expression parser and options.</p>
</td></tr><tr class="module-item"><td><a class="mod" href="print/index.html" title="lexpr::print mod">print</a></td><td class="docblock-short"><p>Converting S-expression values into text.</p>
</td></tr><tr class="module-item"><td><a class="mod" href="value/index.html" title="lexpr::value mod">value</a></td><td class="docblock-short"><p>The Value enum, a dynamically typed way of representing any valid S-expression value.</p>
</td></tr></table><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2>
<table><tr class="module-item"><td><a class="macro" href="macro.sexp.html" title="lexpr::sexp macro">sexp</a></td><td class="docblock-short"><p>Construct a <a href="enum.Value.html"><code>Value</code></a> using syntax similar to regular S-expressions.</p>
</td></tr></table><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.Cons.html" title="lexpr::Cons struct">Cons</a></td><td class="docblock-short"><p>A Lisp &quot;cons cell&quot;.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Datum.html" title="lexpr::Datum struct">Datum</a></td><td class="docblock-short"><p>Combines an S-expression value with location information.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Number.html" title="lexpr::Number struct">Number</a></td><td class="docblock-short"><p>Represents an S-expression number, whether integer or floating point.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Parser.html" title="lexpr::Parser struct">Parser</a></td><td class="docblock-short"><p>Parser for the S-expression text representation.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Printer.html" title="lexpr::Printer struct">Printer</a></td><td class="docblock-short"><p>A printer for S-expression values.</p>
</td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.Value.html" title="lexpr::Value enum">Value</a></td><td class="docblock-short"><p>Represents an S-expression value.</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.Index.html" title="lexpr::Index trait">Index</a></td><td class="docblock-short"><p>A type that can be used to index into a <code>lexpr::Value</code>.</p>
</td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="module-item"><td><a class="fn" href="fn.from_reader.html" title="lexpr::from_reader fn">from_reader</a></td><td class="docblock-short"><p>Parse a value from an IO stream of S-expressions, using the default parser
options.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_reader_custom.html" title="lexpr::from_reader_custom fn">from_reader_custom</a></td><td class="docblock-short"><p>Parse a value from an IO stream containing a single S-expression.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_slice.html" title="lexpr::from_slice fn">from_slice</a></td><td class="docblock-short"><p>Parse a value from bytes representing a single S-expressions, using the
default parser options.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_slice_custom.html" title="lexpr::from_slice_custom fn">from_slice_custom</a></td><td class="docblock-short"><p>Parse a value from bytes representing a single S-expression.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_str.html" title="lexpr::from_str fn">from_str</a></td><td class="docblock-short"><p>Parse a value from a string slice representing a single S-expressions, using
the default parser options.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_str_custom.html" title="lexpr::from_str_custom fn">from_str_custom</a></td><td class="docblock-short"><p>Parse a value from a string slice representing a single S-expression.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.to_string.html" title="lexpr::to_string fn">to_string</a></td><td class="docblock-short"><p>Serialize the given value an S-expression string,
using the default printer options.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.to_string_custom.html" title="lexpr::to_string_custom fn">to_string_custom</a></td><td class="docblock-short"><p>Serialize the given value an S-expression string.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.to_vec.html" title="lexpr::to_vec fn">to_vec</a></td><td class="docblock-short"><p>Serialize the given value as byte vector containing S-expression text, using
the default printer options.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.to_vec_custom.html" title="lexpr::to_vec_custom fn">to_vec_custom</a></td><td class="docblock-short"><p>Serialize the given value as byte vector containing S-expression text.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.to_writer.html" title="lexpr::to_writer fn">to_writer</a></td><td class="docblock-short"><p>Serialize the given value value as S-expression text into the IO stream,
using the default printer options.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.to_writer_custom.html" title="lexpr::to_writer_custom fn">to_writer_custom</a></td><td class="docblock-short"><p>Serialize the given value value as S-expression text into the IO stream.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="lexpr"></div>
    <script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>